<!DOCTYPE html><html lang="en"><head><style>:where(body){all: unset;margin:0;overflow:hidden;}</style></head><body><script type="text/javascript">'use strict';
globalThis.mdlr = (() => {
const m = {
names: /^(?:\[(?<t>[a-z]+)\])?(?<n>[-:a-z0-9_]+)$/,
modules: new Map,
loader: new Map,
info: (name, type = 'unit') => {
const [, t, n] = m.names.exec(name) ?? [];
return { type: t ?? type, n: `[${t ?? type}]${n}` };
},
load: (info, context) => {
return m.loader.get(info.type)(info, context);
}
}
m.loader
.set('unit', (info, context) => {
const scope = new Modular(info, context);
return m.modules.get(info.n)(scope);
})
.set('mdlr', m.loader.get('unit'))
.set('node', info => require(info.n.replace('[node]', '')));
class Modular {
constructor(info, context = {}) {
this.context = context;
this.name = info.n;
if (info.type === 'mdlr') {
this.$ = k => m[k];
}
}
require(name, context) {
return this.context[name] ?? m.load(m.info(name), context);
}
}
return (name, context) => {
const info = m.info(name);
if (context?.constructor === Function) {
m.modules.set(info.n, context);
}
else {
return m.load(info, context);
}
}
})()
mdlr('[html]mdlr-blog', m => {
const { Router } = m.require('core:router');
const { $root, $raw } = m.require('www-root');
m.require('[html]blog-overview');
m.require('[html]blog-post');
m.html`
<header><a href="${$root}"><img src="${$raw}resources/mdlr.svg"/></a></header>
{#if !post}
<blog-overview{=} />
{:else}
<blog-post{=post} />
{/if}
<footer><a href="https://github.com/kootstra-rene/mdlr-tutorials"><img src="${$raw}resources/github.png" /></a></footer>`
m.css`
:root {
display:flex;
flex-direction: column;
width: 80vw;
height: 100%;
transform: translate(10vw,0);
align-items: center;
box-shadow: rgba(0, 0, 0, 0.5) 0px 6px 32px 0px, rgba(0, 0, 0, 0.6) 0px 6px 16px 0px;
background-color: #fff;
}
blog-post, blog-overview {
width: 80vw;
flex: 1;
overflow: hidden;
}
header, footer {
width: 100%;
background-color: #ccc;
flex: none;
text-align: center;
line-height: 2em;
height: 2em;
overflow: hidden;
}
header > a {
display: inline-block;
height: 100%;
}
header > a > img {
aspect-ratio: 2/1;
height: 100%;
}
footer {
line-height: 1.6em;
height:1.6em;
}
footer > a > img {
position:relative;
top: 0.2em;
height:1.2em;
}`;
return class {
blog = [];
post = null;
#router = new Router();
constructor() {
this.#router.get('/', () => {
this.post = null;
m.redraw(this);
})
this.#router.get('/posts/:slug', ({ path }) => {
this.post = this.blog.find(p => p.slug === path);
m.redraw(this);
})
}
async connected() {
const meta = document.createElement('meta');
meta.name = m.name;
meta.content = "Created with mdlr";
document.head.append(meta);
document.title = m.name;
document.body.style.cssText = `
height: 100vh;
width: 100vw;
overflow-y: hidden;
position: absolute;
background-color:#666;
`;
this.blog = await fetch(`${$raw}all.json`).then(r => r.json());
this.#router.connect(window.location.href);
}
disconnect() {
this.#router.disconnect();
}
}
})
mdlr('[unit]core:router', m => {
const { decode } = m.require('router-url');
const endpoints = { get: [], put: [], head: [], post: [], delete: [], options: [] };
function register(method, route, handler) {
const server = decode(`https://dontcare${route}`).server;
endpoints[method] = endpoints[method].filter(a => a.path !== route);
endpoints[method].push(Object.assign({}, server, { handler }));
}
function shim(route, call) {
return {
get path() {
return call.path;
},
get params() {
return Object.seal(call.path.match(route.regex)?.groups ?? {});
},
get search() {
return Object.seal(Object.fromEntries(call.search));
}
}
}
class Router {
#mode = 'client';
#endpoints = { get: [] };
#handler = this.handler.bind(this);
constructor(mode = 'client') {
this.#mode = mode;
this.get = this.register.bind(this, 'get');
}
register(method, route, handler) {
const descriptor = decode(`https://dontcare${route}`).server;
this.#endpoints[method] = this.#endpoints[method].filter(a => a.path !== route);
this.#endpoints[method].push(Object.assign({}, descriptor, { handler }));
}
filter(method, descriptor) {
const route = descriptor[this.#mode] ?? { path: '/' };
return this.#endpoints[method]
.filter(a => a.regex.test(route.path))
.map(a => () => a.handler.call(a, shim(a, route)))
}
handler(e) {
const list = this.filter('get', decode(e.newURL));
if (list.length === 1) {
return list[0]();
}
}
connect(url) {
window.addEventListener('hashchange', this.#handler);
if (url) this.#handler({ newURL: url });
}
disconnect() {
window.removeEventListener('hashchange', this.#handler);
}
}
return {
Router
}
})
mdlr('[unit]www-root', m => {
const loc = window.location;
const $raw = loc.pathname === '/bundler/html' ? `${loc.origin}/docs/` : loc.href.split('#')[0];
const $root = loc.href.replace(loc.hash, '');
return { $root, $raw };
})
mdlr('[html]blog-overview', m => {
m.require('[html]blog-post-title');
m.require('[html]blog-overview-item');
m.html`
<blog-post-title{=} />
<div>
{#each post in blog}
<blog-overview-item{=post} />
<hr />
{:else}
<span>...</span>
{/each}
</div>
`
m.css`
:root {
display: grid;
}
:root > div {
overflow-y: auto;
}
blog-post-title {
line-height: 8vh;
height: 8vh;
}
blog-overview-item {
margin: 0.5em 0;
}
blog-overview-item + blog-overview-item {
border-top: 0;
}`;
return class {
blog = null;
title = 'The official blog';
}
})
mdlr('[html]blog-post', m => {
const { $raw } = m.require('www-root');
m.require('[html]blog-post-title');
m.require('[html]blog-post-sections');
m.html`
<blog-post-title title={post?.title} />
<blog-post-sections{=} />`
m.css`
:root {
display: flex;
flex-direction: column;
}
blog-post-title {
line-height: 3em;
height: 3em;
flex: none;
}
blog-post-sections {
flex: 1;
}`;
const contentRegEx = /-{3}\n(?<head>.*)-{3}\s*(?<body>[^$]*)/s;
function postToJson({ head, body }, slug) {
const meta = head.split(/\n/g).filter(a => a).map(a => a.split(/\s*:\s*/g)).reduce((a, [k, v]) => { a[k] = JSON.parse(v); return a; }, {});
return Object.assign({ slug }, meta, { body })
}
return class {
slug = null;
body = null;
post = null;
async connected() {
const content = this.body ?? await fetch(`${$raw}${this.slug}`, {cache: 'no-cache'}).then(r => r.text());
this.post = this.#contentToJson(content);
m.redraw(this);
}
#contentToJson(content) {
return postToJson(contentRegEx.exec(content).groups, this.slug);
}
}
})
mdlr('[mdlr]html-loader', _ => {
const cache = new Map;
const $cache = new Map;
const { tokenizer } = _.require('html-tokenizer');
const eachRegEx = /^(?<item>[a-zA-Z0-9-]+(,\s*[a-zA-Z0-9-]+)?) in (?<member>[^}]+)$/;
const attrRegEx = /^(?<n>[a-zA-Z0-9-]*)(?<d>{(?<e>[^}:]*?)(:(?<h>[^}]*))?})?$/;
const openRegEx = /^(?<n>[a-zA-Z0-9-]*)(?<d>{(?<e>[^}=]*?)(=(?<h>[^}]*))?})?$/;
const copyRegEx = /^\{(?<code>[^}]+)\}|(?<text>.*)$/;
function defineElement(name, e, $) {
customElements.define(name, class extends HTMLElement {
#state = e.bind(new $);
connectedCallback() {
const s = this.#state;
const record = { nodes: [], $root: this, e };
$cache.set(s, record);
e.create(s, record.nodes, record.$root);
s.connected?.call(s, this);
}
disconnectedCallback() {
const s = this.#state;
e.delete(s);
$cache.delete(s);
s.disconnected?.call(s, this);
}
get $() {
return this.#state;
}
});
}
function html(strings, ...values) {
let create = 'let $i=0, $t=[]; $t[0] = $e[0] = $d.createDocumentFragment();\n';
let update = 'let $i=0;\n';
let hs = [];
const add = (c, u = true) => { create += c; if (u) update += c; }
const markup = String.raw({ raw: strings }, ...values)
for (let { id, type, data } of tokenizer(markup)) {
let code;
switch (type) {
case 'open':
const { n, e, h, d } = openRegEx.exec(id).groups;
const isHtmlModule = cache.has(n);
const xmlns = (data.find(a => a.key === 'xmlns') ?? {}).value;
create += `$e[++$i] = $d.createElementNS(${xmlns ? `'${xmlns}'` : '($t[0].namespaceURI ?? \'http://www.w3.org/1999/xhtml\')'}, '${n}');\n`;
if (d) {
const m = (h || e) || n;
if (e) {
create += `$.${e} = $e[$i].$ ?? $e[$i];\n`;
}
if (h !== undefined && h !== null) {
const v = h || '$';
cache.get(n).keys.forEach(k => {
add(`if(${v}.${k}) ${e || '$e[$i].$'}.${k} = ${v}.${k};\n`);
});
}
}
update += '++$i;\n';
data.forEach(({ key: k, value: v }) => {
if (k === 'on') {
let { e, h } = attrRegEx.exec(v).groups;
create += `$e[$i].addEventListener('${e}', ${h ?? e});\n`;
return;
}
if (v === '{}') v = `{${k}}`;
if (isHtmlModule) {
const g = (copyRegEx.exec(v) ?? {}).groups;
if (g.text) {
code = `$e[$i].$.${k} = \'${g.text}\';\n`;
}
if (g.code) {
const rk = (g.code || k)?.split('.')[0];
code = `$e[$i].$.${k} = ${g.code || k};\n`;
}
}
else {
code = `$e[$i].setAttribute('${k}', \`${v.replace(/\{/g, '${')}\`);\n`;
}
add(code, v.indexOf('{') !== -1);
})
create += `$t[0].append($e[$i]);\n`;
create += `$t.unshift($e[$i]);\n`;
break;
case 'text':
create += `$e[++$i] = $d.createTextNode('');\n`;
update += '++$i;\n';
code = `$e[$i].textContent = \`${data.replace(/\{/g, '${')}\`;\n`;
add(code, data.indexOf('{') !== -1);
create += `$t[0].append($e[$i]);\n`;
break;
case 'close':
add(`$t.shift();\n`, false);
break;
case 'hint':
switch (id) {
case '#each': {
const g = eachRegEx.exec(data).groups;
add(`if(${g.member}?.length){ ${g.member}.forEach((${g.item}) => {\n`);
hs.unshift(id);
} break;
case ':else':
add(`${hs[0] === '#each' ? '});' : ''}} else {\n`);
hs[0] = id;
break;
case '/each':
add(`${hs[0] === '#each' ? '});' : ''}};\n`);
hs.shift();
break;
case '#if':
hs.unshift(id);
add(`if (${data}) {\n`);
break
case ':elseif':
hs[0] = id;
add(`} else if (${data}) {\n`);
break
case '/if':
hs.shift();
add(`}\n`);
break;
case '@html':
// todo: verify html?
create += `$e[++$i] = $d.createElement('template');\n`;
update += '++$i;\n';
code = `$e[$i].innerHTML = \`\${${data}}\`;\n`;
add(code, data.indexOf('{') !== -1);
create += `$t[0].append($e[$i].content);\n`;
break;
}
break;
}
}
this.create = create;
this.update = update;
}
function css(name, strings, ...values) {
const markup = String.raw({ raw: strings }, ...values)
const block = /\s*(?<key>.+?)\s*\{(?<body>[^}]*)\}/g;
let b, style = '';
while (!!(b = block.exec(markup))) {
const { key, body } = b.groups;
const keys = key.split(',').map(a => a.trim());
keys.forEach(k => {
if (k.indexOf(':root') === 0) {
style += `${k.replace(':root', name)} {${body}}\n`;
}
else {
style += `${name} ${k} {${body}}\n`;
}
});
}
const e = document.createElement('style');
e.id = name;
e.textContent = style;
document.head.append(e);
}
_.$('loader').set('html', (i, context) => {
const name = i.n.replace('[html]', '');
if (cache.has(name)) return;
const config = {};
const m = new _.constructor(i, context);
m.html = html.bind(config);
m.css = css.bind(config, name);
const stateClass = _.$('modules').get(i.n)(m) ?? class { };
const state = new stateClass;
const names = Object.getOwnPropertyNames;
const funcs = names(stateClass.prototype);
const props = [...names(state), ...funcs].join(', ');
const functor = new Function(`//${name}\nconst $d = document, $keys = new Set([${[...names(state)].map(a => `'${a}'`).join(',')}]); return {
bind: $ => { ${funcs.map(f => `$.${f} = $.${f}.bind($);`).join('\n')}; return $; },
create: ($, $e, $root) => {\nconst {${props}} = $\n${config.create}\$root.textContent='';\$root.append($e[0]);\n},
update: ($, $e, $root) => {\nconst {${props}} = $;\n${config.update}},
delete: () => {}
}`);
const e = functor();
defineElement(name, e, stateClass);
m.redraw = $ => {
if (!$cache.has($)) return;
const { nodes, $root, e } = $cache.get($);
e.create($, nodes, $root);
}
m.render = $ => {
if (!$cache.has($)) return;
const { nodes, $root, e } = $cache.get($);
e.update($, nodes, $root);
}
m.redirect = path => {
const { hash, href } = globalThis.location;
globalThis.location.href = href.replace(hash, path);
}
cache.set(name, { stateClass, keys: [...names(state)] });
globalThis.cache = cache;
})
})
mdlr('[unit]router-url', m => {
function matcher(path) {
const parts = path.split('/').map(a => a[0] !== ':' ? (a === '*' ? '.+' : a) : `(?<${a.slice(1)}>[^/]+)`);
return new RegExp(`^${parts.join('/')}$`);
}
function block(url) {
return !url ? null : {
path: url.pathname,
hash: url.hash.slice(1),
regex: matcher(url.pathname),
search: url.searchParams
}
}
function decode(url) {
const server = new URL(decodeURI(url));
let [, hash, path] = server.hash.split('#');
let client;
if (hash && hash[0] === '/') {
client = new URL(hash ?? '', server.origin);
hash = '';
}
else {
client = new URL(path ?? '', server.origin);
}
client.hash = hash ?? '';
server.hash = '';
return {
origin: server.origin,
server: block(server),
client: hash !== undefined ? block(client) : null
};
}
return { decode };
})
mdlr('[html]blog-post-title', m => {
m.html`<div>{title ?? ''}</div>`;
m.css`
:root {
display: block;
white-space: nowrap;
font-size: 2em;
text-align: center;
background-color: #555;
font-weight: bold;
font-spacing:0.1em;
box-shadow: inset 0 0px 50px #333;
}
div {
color: #ffffffe0;
text-shadow: 1px 2px 4px #000, 0 0 0 #000, 1px 2px 4px #555;
}`;
return class {
title = null;
} 
})
mdlr('[html]blog-overview-item', m => {
m.html`
<a href={'#'+slug}>
<h1>{title}</h1><h2>{tldr}</h2>
<span>more...</span>
{#each tag in tags}<li>{tag}</li>{/each}
</a>`;
m.css`
:root {
display: block;
padding: 0 1em;
}
li {
all: unset;
box-sizing: border-box;
border: 1px solid #777;
font-size:0.8em;
line-height: 1.0em;
height: 1.3em;
padding: 0 0.5em;
border-radius: 0.9em;
color: #777;
float: right;
margin: 0 0.25em;
cursor: pointer
}
li + li {
margin: 0 0 0 0.25em;
}
h1 {
margin: 0;
padding-top: 0.25em;
font-size: 1.5em;
}
h2 {
margin: 0;
margin-bottom: 0.25em;
color: #777;
font-weight: unset;
font-size: 1.1em;
}
a {
all: inherit;
cursor: pointer;
}
span {
text-decoration: underline #bbb;
color: #777;
font-size: 0.8em;
}`;
return class {
title = null;
tldr = null;
slug = null;
tags = null;
}
})
mdlr('[html]blog-post-sections', m => {
m.require('[html]blog-post-section-text');
m.html`
{#if post?.type !== "code"}
<a href="https://github.com/kootstra-rene/mdlr-tutorials/tree/main/docs/{post?.slug}">edit</a>
{/if}
<blog-post-section-text{=} />`;
m.css`
* {
box-sizing: border-box;
user-select: none;
font-family: sans-serif;
}
:root {
height: 100%;
overflow-y: auto;
display: block;
box-shadow: 0 0 black;
}
:root > a {
position:absolute;
right:0.75em;
top:0em;
height: 2em;
line-height:2em;
}`;
return class {
post = null;
} 
})
mdlr('[unit]html-tokenizer', m => {
const attributesRegEx = /(?<key>[a-zA-Z0-9\-]+)=(?:"(?<value1>(?:\\"|[^"\r\n])*)"|(?<value2>(?:\\"|[^\x20>\r\n])*))/g;
const tagRegEx = /(?<space>[\s]+)(?=<|$|{)|\<\/(?<close>[^>]+)\>|\<(?<open>(?<tag>[a-z0-9-]+)({[^}]*})?)[^>]*\>|{(?<hint>[#:\/@][a-z]+)[\s]*(?<body>({[^}]*}|[^{}]*)*)}|(?<text>[^<]+)/g;
function getAttributes(match) {
return [...match.matchAll(attributesRegEx)].map(a => a.groups).map(a => ({ key: a.key, value: (a.value1 ?? a.value2) }));
}
function* tokenizer(html) {
tagRegEx.lastIndex = 0;
const $ = (id, type, data = null) => ({ id, type, data });
let m;
while (null != (m = tagRegEx.exec(html))) {
const { space, close, open, tag, hint, body, text } = m.groups;
if (open) {
yield $(open, 'open', getAttributes(m[0]));
if (m[0].endsWith('/>')) {
yield $(open, 'close');
}
}
else if (close) {
yield $(close, 'close');
}
else if (space) {
yield $(null, 'space', space);
}
else if (text) {
yield $(null, 'text', text);
}
else if (hint) {
yield $(hint, 'hint', body);
}
}
}
return { tokenizer };
})
mdlr('[html]blog-post-section-text', m => {
const { md } = m.require('markdown');
m.html`{@html md([post?.body ?? '...'])}`;
m.css`
:root {
display: inline-block;
text-align: justify;
font-size: 1.2em;
line-height: 1.2em;
width: 100%;
padding: 1em 3em;
}
li {
list-style-position: outside;
}
s {
text-decoration: underline;
text-underline-offset: -.25em;
text-decoration-skip-ink: none;
}
sup, sub {
line-height: 0;
font-size: 70%;
}
iframe, img {
border: 0;
position: relative;
height: 7.2em;
width: auto;
}
iframe {
aspect-ratio: 1 / 1;
}
.float-left {
float: left;
padding: 0 0.6em 0.5em 0;
}
.float-right {
float: right;
padding: 0 0 0.5em 0.6em;
}
.center {
display: block;
padding: 0.5em;
position: relative;
left: 50%;
transform: translate(-50%, 0);
}
pre {
font-family: monospace;
border-left: 0.25em solid #aaa;
padding-left: 0.75em;
font-size: 0.9em;
line-height: 1.4em;
}
h1, h2, h3, h4, h5, h6 {
color: #444;
}
code {
display:inline;
font-family: monospace;
background: #888;
border-radius: 0.7em;
padding: 0 0.5em 0.1em 0.5em;
font-size: 0.9em;
line-height: 1.4em;
display: inline;
top: -0.1em;
position: relative;
color: #fff;
}`;
return class {
md = md;
post = null;
}
})
mdlr('[unit]markdown', m => {
const { $raw } = m.require('www-root');
const whiteSpaceRegEx = /(^\s*)|(\s*$)/mg;
const linebreakReqEx = /\u0020{2,4}\n/mg;
const headingReqEx = /^\u0020{0,3}(#{1,6})\u0020*([^\n]*)/mg;
const inlineReqEx = /(\\?)(!?)\[([^\]]*)\]\(([^\)\|]*)(?:\|([^\)]*))?\)/g;
const emphasisRegEx = /(\*{1,3})([^*]+)(\*{1,3})/g;
const strikeRegEx = /(~{1,2})([^~]+)(~{1,2})/g;
const scriptRegEx = /(\^{1,2})([^^]+)(\^{1,2})/g;
const codeRegEx = /((?:\\?)`{3,3})((?:[^`]+?|`)*?)(`{3,3})|((?:\\?)`([^`]+)`)/mg;
const bulletReqEx = /^(\u0020{0,6})([-][\u0020]*)([^\n]*)/mg;
const emphasis = { otag: ['<i>', '<b>', '<b><i>'], etag: ['</i>', '</b>', '</i></b>'] };
const strike = { otag: ['<u>', '<s>'], etag: ['</u>', '</s>'] };
const script = { otag: ['<sub>', '<sup>'], etag: ['</sub>', '</sup>'] };
function emphasisReplacer(match, p1, p2, p3) {
if (p1.length !== p3.length) return match;
const type = p1.length - 1;
return `${emphasis.otag[type]}${p2}${emphasis.etag[type]}`;
}
function strikeReplacer(match, p1, p2, p3) {
if (p1.length !== p3.length) return match;
const type = p1.length - 1;
return `${strike.otag[type]}${p2}${strike.etag[type]}`;
}
function scriptReplacer(match, p1, p2, p3) {
if (p1.length !== p3.length) return match;
const type = p1.length - 1;
return `${script.otag[type]}${p2}${script.etag[type]}`;
}
function escape(t) {
return t.replace(/</g, '&lt;').replace(/\u0020/g, '&nbsp;')
}
function codeReplacer(match, p1, p2, p3, p4) {
if (p4?.length) {
if (p4[0] === '\\') return match.slice(1);
return `<code>${p4.slice(1, p4.length - 1)}</code>`;
}
if (p1[0] === '\\') return escape(match.slice(1));
return `<pre>${escape(p2)}</pre>`;
}
function linebreakReplacer(match) {
const breaks = (match.length - 1) >> 1;
return '<br>'.repeat(breaks);
}
function headingReplacer(match, p1, p2) {
return `<h${p1.length}>${p2.trim()}</h${p1.length}>`;
}
function bulletReplacer(match, p1, p2, p3) {
return `<li style="padding-left:${(p1.length >> 1)}em">${p3}</li>`;
}
function inlineReplacer(match, ...args) {
let [esc, show, name, href, props] = args;
if (href.startsWith('link:')) return `<a href="${href.slice(5)}" onclick="const { hash, href } = globalThis.location; globalThis.location.href = href.replace(hash, ${href.slice(5)});">${name}</a>`;
href = href.replace('#/', $raw);
if (!show) return `<a href="${href}">${name}</a>`;
if (esc) return `\`${match.slice(1)}\``;
if (href.endsWith('.png')) return `<img alt="${name}" src="${href}" ${props || ''}/>`;
if (href.startsWith('mdlr:')) return `<iframe title="${name}" src="${href.replace('mdlr:', 'https:')}" ${props || ''}></iframe>`;
return `<iframe title="${name}" src="${href}" sandbox="allow-scripts allow-same-origin" ${props || ''}></iframe>`;
}
function md(strings, ...values) {
return String
.raw({ raw: strings }, ...values)
.replace(inlineReqEx, inlineReplacer)
.replace(bulletReqEx, bulletReplacer)
.replace(headingReqEx, headingReplacer)
.replace(emphasisRegEx, emphasisReplacer)
.replace(strikeRegEx, strikeReplacer)
.replace(scriptRegEx, scriptReplacer)
.replace(codeRegEx, codeReplacer)
.replace(linebreakReqEx, linebreakReplacer)
.replace(whiteSpaceRegEx, '');
}
return { md };
})
mdlr('[mdlr]html-loader');
mdlr('[html]mdlr-blog'); document.body.innerHTML = '<mdlr-blog></mdlr-blog>';</script></body></html>