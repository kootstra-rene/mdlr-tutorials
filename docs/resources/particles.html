<!DOCTYPE html><html lang="en"><head><style>:where(body){all: unset;margin:0;overflow:hidden;}</style></head><body><script type="text/javascript">'use strict';
globalThis.mdlr = (() => {
const m = {
names: /^(?:\[(?<t>[a-z]+)\])?(?<n>[-:a-z0-9]+)$/,
modules: new Map,
loader: new Map,
checks: new Set,
info: (name, type = 'unit') => {
const [ , t, n ] = m.names.exec(name) ?? [];
return { type:t??type, n:`[${t??type}]${n}` };
},
load: (info, context) => {
return m.loader.get(info.type)(info, context);
}
}
m.loader
.set('unit', (info, context) => {
const scope = new Modular(info, context);
const unit = m.modules.get(info.n)(scope);
// todo: move this check to static analisys
if (undefined !== unit && '[object Object]' !== Object.prototype.toString.call(unit)) {
if (!m.checks.has(info.n)) {
console.error(info, 'should return an object');
m.checks.add(info.n);
}
}
return unit;
})
.set('mdlr', m.loader.get('unit'))
.set('node', info => require(info.n.replace('[node]', '')));
class Modular {
constructor(info, context) {
this.context = context ?? {};
this.name = info.n;
if (info.type === 'mdlr') {
this.$ = k => m[k];
}
}
require(name, context) {
if (this.context[name]) {
return this.context[name];
}
const info = m.info(name);
return m.load(info, context);
}
}
return (name, context) => {
const info = m.info(name);
if (context && context.constructor === Function) {
m.modules.set(info.n, context);
}
else {
return m.load(info, context);
}
}
})()
mdlr('[html]blog-particles', m => {
m.html`<canvas{} width=512 height=128 />`;
m.css`
:root {
display: block;
width: 100%;
height: 100%
}
canvas {
width: 100%;
height: 100%
}`;
return class {
canvas = null;
connected() {
const { width: canvasWidth, height: canvasHeight } = this.canvas;
const ctx = this.canvas.getContext('2d', {
alpha: false
});
ctx.lineWidth = 1;
ctx.fillStyle = 'white';
ctx.strokeStyle = 'white';
const maxPs = 24;      // max nr of particles
const threshold = 100; // threshold distance between particles at which a line should be drawn
const speed = 0.5;     // speed of movement; adapt to your environment and preference
function particle() {
return {
x: Math.random() * canvasWidth,
y: Math.random() * canvasHeight,
vx: (Math.random() * speed * 2) - (1 * speed),
vy: (Math.random() * speed * 2) - (1 * speed),
}
}
const ps = Array.from({ length: maxPs }, particle);
function drawCircle(x, y) {
ctx.beginPath();
ctx.arc(x, y, 2, 0, 2 * Math.PI, false);
ctx.fill();
}
// map a point p in a range from a1 to a2
// into a range from b1 to b2 (linearly)
function mapRange(p, a1, a2, b1, b2) {
return (b1 + ((p - a1) * (b2 - b1)) / (a2 - a1));
}
function distance(p1, p2) {
let dx2 = Math.pow((p2.x - p1.x), 2);
let dy2 = Math.pow((p2.y - p1.y), 2);
return Math.sqrt(dy2 + dx2);
}
function drawLine(d, p1, p2) {
ctx.lineWidth = mapRange(d, 0, threshold, 2, 0);
ctx.beginPath();
ctx.moveTo(p1.x, p1.y);
ctx.lineTo(p2.x, p2.y);
ctx.stroke();
}
function drawLines(p1) {
ps.forEach(p2 => {
let d = distance(p1, p2);
if (d < threshold) {
drawLine(d, p1, p2);
}
});
}
function move(p) {
p.x = p.x + p.vx;
p.y = p.y + p.vy;
}
function bounce(p) {
if (p.x < 0 || p.x > canvasWidth) { p.vx = -p.vx }
if (p.y < 0 || p.y > canvasHeight) { p.vy = -p.vy }
}
function clearFrame() {
ctx.clearRect(0, 0, canvasWidth, canvasHeight);
}
function drawFrame() {
ps.forEach(p => { drawCircle(p.x, p.y); });
ps.forEach(p => { drawLines(p); });
ps.forEach(p => {
move(p);
bounce(p);
});
}
function animate() {
requestAnimationFrame(animate);
clearFrame();
drawFrame();
}
requestAnimationFrame(animate);
}
};
})
mdlr('[mdlr]html-loader', _ => {
const cache = new Map;
const $cache = new Map;
const { tokenizer } = _.require('html-tokenizer');
const eachRegEx = /^(?<item>[a-zA-Z0-9-]+(,\s*[a-zA-Z0-9-]+)?) in (?<member>[^}]+)$/;
const attrRegEx = /^(?<n>[a-zA-Z0-9-]*)(?<d>{(?<e>[^}:]*?)(:(?<h>[^}]*))?})?$/;
const copyRegEx = /^\{(?<code>[^}]+)\}|(?<text>.*)$/;
function defineElement(name, e, $) {
customElements.define(name, class extends HTMLElement {
#state = e.bind(new $);
connectedCallback() {
const s = this.#state;
const record = { nodes: [], $root: this, e };
$cache.set(s, record);
e.create(s, record.nodes, record.$root);
s.connected?.call(s, this);
}
disconnectedCallback() {
const s = this.#state;
e.delete(s);
$cache.delete(s);
s.disconnected?.call(s, this);
}
get $() {
return this.#state;
}
});
}
function html(strings, ...values) {
let create = 'let $i=0, $t=[]; $t[0] = $e[0] = $d.createDocumentFragment();\n';
let update = 'let $i=0;\n';
let hs = [];
const add = (c, u = true) => { create += c; if (u) update += c; }
const markup = String.raw({ raw: strings }, ...values)
for (let { id, type, data } of tokenizer(markup)) {
let code;
switch (type) {
case 'open':
const { n, e, h, d } = attrRegEx.exec(id).groups;
const isHtmlModule = cache.has(n);
const xmlns = (data.find(a => a.key === 'xmlns') ?? {}).value;
create += `$e[++$i] = $d.createElementNS(${xmlns ? `'${xmlns}'` : '($t[0].namespaceURI ?? \'http://www.w3.org/1999/xhtml\')'}, '${n}');\n`;
if (d) {
const m = (h || e) || n;
if (m[0] !== '=') {
create += `$.${m} = $e[$i].$ ?? $e[$i];\n`;
}
else {
const v = m.slice(1) || '$';
cache.get(n).keys.forEach(k => {
add(`if(${v}.${k}) $e[$i].$.${k} = ${v}.${k};\n`);
});
}
}
update += '++$i;\n';
data.forEach(({ key: k, value: v }) => {
if (k === 'on') {
let { e, h } = attrRegEx.exec(v).groups;
create += `$e[$i].addEventListener('${e}', ${h ?? e});\n`;
return;
}
if (v === '{}') v = `{${k}}`;
if (isHtmlModule) {
const g = (copyRegEx.exec(v) ?? {}).groups;
if (g.text) {
code = `$e[$i].$.${k} = \'${g.text}\';\n`;
}
if (g.code) {
const rk = (g.code || k)?.split('.')[0];
code = `$e[$i].$.${k} = ${g.code || k};\n`;
}
}
else {
code = `$e[$i].setAttribute('${k}', \`${v.replace(/\{/g, '${')}\`);\n`;
}
add(code, v.indexOf('{') !== -1);
})
create += `$t[0].append($e[$i]);\n`;
create += `$t.unshift($e[$i]);\n`;
break;
case 'text':
create += `$e[++$i] = $d.createTextNode('');\n`;
update += '++$i;\n';
code = `$e[$i].textContent = \`${data.replace(/\{/g, '${')}\`;\n`;
add(code, data.indexOf('{') !== -1);
create += `$t[0].append($e[$i]);\n`;
break;
case 'close':
add(`$t.shift();\n`, false);
break;
case 'hint':
switch (id) {
case '#each': {
const g = eachRegEx.exec(data).groups;
add(`if(${g.member}?.length){ ${g.member}.forEach((${g.item}) => {\n`);
hs.unshift(id);
} break;
case ':else':
add(`${hs[0] === '#each' ? '});' : ''}} else {\n`);
hs[0] = id;
break;
case '/each':
add(`${hs[0] === '#each' ? '});' : ''}};\n`);
hs.shift();
break;
case '#if':
hs.unshift(id);
add(`if (${data}) {\n`);
break
case ':elseif':
hs[0] = id;
add(`} else if (${data}) {\n`);
break
case '/if':
hs.shift();
add(`}\n`);
break;
case '@html':
// todo: verify html?
create += `$e[++$i] = $d.createElement('template');\n`;
update += '++$i;\n';
code = `$e[$i].innerHTML = \`\${${data}}\`;\n`;
add(code, data.indexOf('{') !== -1);
create += `$t[0].append($e[$i].content);\n`;
break;
}
break;
}
}
this.create = create;
this.update = update;
}
function css(name, strings, ...values) {
const markup = String.raw({ raw: strings }, ...values)
const block = /\s*(?<key>.+?)\s*\{(?<body>[^}]*)\}/g;
let b, style = '';
while (!!(b = block.exec(markup))) {
const { key, body } = b.groups;
const keys = key.split(',').map(a => a.trim());
keys.forEach(k => {
if (k.indexOf(':root') === 0) {
style += `${k.replace(':root', name)} {${body}}\n`;
}
else {
style += `${name} ${k} {${body}}\n`;
}
});
}
const e = document.createElement('style');
e.id = name;
e.textContent = style;
document.head.append(e);
}
_.$('loader').set('html', (i, context) => {
const name = i.n.replace('[html]', '');
if (cache.has(name)) return;
const config = {};
const m = new _.constructor(i, context);
m.html = html.bind(config);
m.css = css.bind(config, name);
const stateClass = _.$('modules').get(i.n)(m) ?? class { };
const state = new stateClass;
const names = Object.getOwnPropertyNames;
const funcs = names(stateClass.prototype);
const props = [...names(state), ...funcs].join(', ');
const functor = new Function(`//${name}\nconst $d = document, $keys = new Set([${[...names(state)].map(a => `'${a}'`).join(',')}]); return {
bind: $ => { ${funcs.map(f => `$.${f} = $.${f}.bind($);`).join('\n')}; return $; },
create: ($, $e, $root) => {\nconst {${props}} = $\n${config.create}\$root.textContent='';\$root.append($e[0]);\n},
update: ($, $e, $root) => {\nconst {${props}} = $;\n${config.update}},
delete: () => {}
}`);
const e = functor();
defineElement(name, e, stateClass);
m.redraw = $ => {
if (!$cache.has($)) return;
const { nodes, $root, e } = $cache.get($);
e.create($, nodes, $root);
}
m.render = $ => {
if (!$cache.has($)) return;
const { nodes, $root, e } = $cache.get($);
e.update($, nodes, $root);
}
m.redirect = path => {
const { hash, href } = window.location;
window.location.href = href.replace(hash, path);
}
cache.set(name, { stateClass, keys: [...names(state)] });
window.cache = cache;
})
})
mdlr('[unit]html-tokenizer', m => {
const attributesRegEx = /(?<key>[a-zA-Z0-9\-]+)=(?:"(?<value1>(?:\\"|[^"\r\n])*)"|(?<value2>(?:\\"|[^\x20>\r\n])*))/g;
const tagRegEx = /(?<space>[\s]+)(?=<|$|{)|\<\/(?<close>[^>]+)\>|\<(?<open>(?<tag>[a-z0-9-]+)({[^}]*})?)[^>]*\>|{(?<hint>[#:\/@][a-z]+)[\s]*(?<body>({[^}]*}|[^{}]*)*)}|(?<text>[^<]+)/g;
function getAttributes(match) {
return [...match.matchAll(attributesRegEx)].map(a => a.groups).map(a => ({ key: a.key, value: (a.value1 ?? a.value2) }));
}
function* tokenizer(html) {
tagRegEx.lastIndex = 0;
const $ = (id, type, data = null) => ({ id, type, data });
let m;
while (null != (m = tagRegEx.exec(html))) {
const { space, close, open, tag, hint, body, text } = m.groups;
if (open) {
yield $(open, 'open', getAttributes(m[0]));
if (m[0].endsWith('/>')) {
yield $(open, 'close');
}
}
else if (close) {
yield $(close, 'close');
}
else if (space) {
yield $(null, 'space', space);
}
else if (text) {
yield $(null, 'text', text);
}
else if (hint) {
yield $(hint, 'hint', body);
}
}
}
return { tokenizer };
})
mdlr('[mdlr]html-loader');
mdlr('[html]blog-particles'); document.body.innerHTML = '<blog-particles></blog-particles>';</script></body></html>